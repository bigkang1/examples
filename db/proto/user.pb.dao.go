// Code generated by proto-gen-dao. DO NOT EDIT.
// source: examples/db/proto/user.proto

package userv1

import (
	context "context"
	errors "errors"
	dao "github.com/vine-io/apimachinery/storage/dao"
	gorm "gorm.io/gorm"
	clause "gorm.io/gorm/clause"
	reflect "reflect"
	time "time"
)

func (m *User) SetId(in int32) *User {
	m.Id = in
	return m
}

func (m *User) SetName(in string) *User {
	m.Name = in
	return m
}

func (m *User) SetAge(in int32) *User {
	m.Age = in
	return m
}

type XXUser struct {
	Id                     int32  `json:"id,omitempty" gorm:"column:id;autoIncrement"`
	Name                   string `json:"name,omitempty" gorm:"column:name"`
	Age                    int32  `json:"age,omitempty" gorm:"column:age"`
	InnerDeletionTimestamp int64  `json:"innerDeletionTimestamp,omitempty" gorm:"column:inner_deletion_timestamp"`
}

func FromUser(in *User) *XXUser {
	out := new(XXUser)
	if in.Id != 0 {
		out.Id = in.Id
	}
	if in.Name != "" {
		out.Name = in.Name
	}
	if in.Age != 0 {
		out.Age = in.Age
	}
	return out
}

func (m *XXUser) ToUser() *User {
	out := new(User)
	out.Id = m.Id
	out.Name = m.Name
	out.Age = m.Age
	return out
}

func (m XXUser) PrimaryKey() (string, any, bool) {
	return "id", m.Id, m.Id == 0
}

func (XXUser) TableName() string {
	return "users"
}

// UserStorage the Storage for User
type UserStorage struct {
	tx    *gorm.DB `json:"-" gorm:"-"`
	joins []string `json:"-" gorm:"-"`
	m     *XXUser
	exprs []clause.Expression `json:"-" gorm:"-"`
}

func NewUserStorage(tx *gorm.DB, m *User) *UserStorage {
	return &UserStorage{tx: tx, joins: []string{}, exprs: make([]clause.Expression, 0), m: FromUser(m)}
}
func (s *UserStorage) AutoMigrate() error {
	return s.tx.Migrator().AutoMigrate(&XXUser{})
}

func (s UserStorage) Target() reflect.Type {
	return reflect.TypeOf(new(User))
}

func (s *UserStorage) XXLoad(tx *gorm.DB, in *User) error {
	s.tx = tx
	*s.m = *FromUser(in)
	return nil
}

func (s *UserStorage) XXFindPage(ctx context.Context, page, size int32) ([]*User, int64, error) {
	m := s.m
	pk, _, _ := m.PrimaryKey()

	s.exprs = append(s.exprs,
		clause.OrderBy{Columns: []clause.OrderByColumn{{Column: clause.Column{Table: m.TableName(), Name: pk}, Desc: true}}},
		dao.Cond().Build("inner_deletion_timestamp", 0),
	)

	total, err := s.Count(ctx)
	if err != nil {
		return nil, 0, err
	}

	limit := int(size)
	s.exprs = append(s.exprs, clause.Limit{Offset: int((page - 1) * size), Limit: &limit})
	data, err := s.findAll(ctx)
	if err != nil {
		return nil, 0, err
	}

	return data, total, nil
}

func (s *UserStorage) XXFindAll(ctx context.Context) ([]*User, error) {
	s.exprs = append(s.exprs, dao.Cond().Build("inner_deletion_timestamp", 0))
	return s.findAll(ctx)
}

func (s *UserStorage) XXFindPureAll(ctx context.Context) ([]*User, error) {
	return s.findAll(ctx)
}

func (s *UserStorage) findAll(ctx context.Context) ([]*User, error) {
	dest := make([]*XXUser, 0)
	m := s.m
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(s.extractClauses(tx), s.exprs...)
	for _, item := range s.joins {
		tx = tx.Joins(item)
	}
	if err := tx.Clauses(clauses...).Find(&dest).Error; err != nil {
		return nil, err
	}

	outs := make([]*User, len(dest))
	for i := range dest {
		outs[i] = dest[i].ToUser()
	}

	return outs, nil
}

func (s *UserStorage) Count(ctx context.Context) (total int64, err error) {
	m := s.m
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(s.extractClauses(tx), dao.Cond().Build("inner_deletion_timestamp", 0))
	clauses = append(clauses, s.exprs...)

	err = tx.Clauses(clauses...).Count(&total).Error
	return
}

func (s *UserStorage) XXFindPk(ctx context.Context, id any) (*User, error) {
	m := s.m
	pk, _, _ := m.PrimaryKey()
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	if err := tx.Where(pk+" = ?", id).First(&m).Error; err != nil {
		return nil, err
	}
	return m.ToUser(), nil
}

func (s *UserStorage) XXFindOne(ctx context.Context) (*User, error) {
	m := s.m
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(s.extractClauses(tx), dao.Cond().Build("inner_deletion_timestamp", 0))
	clauses = append(clauses, s.exprs...)

	for _, item := range s.joins {
		tx = tx.Joins(item)
	}
	if err := tx.Clauses(clauses...).First(&m).Error; err != nil {
		return nil, err
	}

	return m.ToUser(), nil
}

func (s *UserStorage) XXFindPureOne(ctx context.Context) (*User, error) {
	m := s.m
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	if err := tx.Clauses(s.exprs...).First(&m).Error; err != nil {
		return nil, err
	}

	return m.ToUser(), nil
}

func (s *UserStorage) XXCond(exprs ...clause.Expression) *UserStorage {
	s.exprs = append(s.exprs, exprs...)
	return s
}

func (s *UserStorage) extractClauses(tx *gorm.DB) []clause.Expression {
	m := s.m
	exprs := make([]clause.Expression, 0)
	if m.Id != 0 {
		exprs = append(exprs, dao.Cond().Build("id", m.Id))
	}
	if m.Name != "" {
		exprs = append(exprs, dao.Cond().Op(dao.ParseOp(m.Name)).Build("name", m.Name))
	}
	if m.Age != 0 {
		exprs = append(exprs, dao.Cond().Build("age", m.Age))
	}

	return exprs
}

func (s *UserStorage) XXCreate(ctx context.Context) (*User, error) {
	m := s.m
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	if err := tx.Create(m).Error; err != nil {
		return nil, err
	}

	return m.ToUser(), nil
}

func (s *UserStorage) XXUpdates(ctx context.Context) (*User, error) {
	m := s.m
	pk, pkv, isNil := m.PrimaryKey()
	if isNil {
		return nil, errors.New("missing primary key")
	}

	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx).Where(pk+" = ?", pkv)

	values := make(map[string]interface{}, 0)
	if m.Name != "" {
		values["name"] = m.Name
	}
	if m.Age != 0 {
		values["age"] = m.Age
	}

	if err := tx.Updates(values).Error; err != nil {
		return nil, err
	}

	err := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx).Where(pk+" = ?", pkv).First(m).Error
	if err != nil {
		return nil, err
	}
	return m.ToUser(), nil
}

func (s *UserStorage) XXDelete(ctx context.Context, soft bool) error {
	m := s.m
	pk, pkv, isNil := m.PrimaryKey()
	if isNil {
		return errors.New("missing primary key")
	}

	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	if soft {
		return tx.Where(pk+" = ?", pkv).Updates(map[string]interface{}{"inner_deletion_timestamp": time.Now().UnixNano()}).Error
	}
	return tx.Where(pk+" = ?", pkv).Delete(&UserStorage{}).Error
}
